import { useState, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/hooks/useAuth';
import { useToast } from '@/hooks/use-toast';

/**
 * Hook para manejar estad√≠sticas de banners y banners permanentes
 * 
 * üéØ ¬øQu√© hace?
 * - Lee estad√≠sticas del usuario desde la base de datos
 * - Obtiene la lista de banners que el usuario ha desbloqueado
 * - Calcula el progreso hacia nuevos banners
 * - Maneja c√≥digos secretos para banners exclusivos
 * 
 * üìä Datos que maneja:
 * - UserStats: estad√≠sticas completas del usuario (mensajes, reacciones, rachas)
 * - DailyStats: estad√≠sticas diarias para c√°lculos espec√≠ficos
 * - UserBanners: banners permanentes desbloqueados
 * - BannerProgress: progreso hacia banners espec√≠ficos
 */

// Estad√≠sticas generales del usuario almacenadas en la base de datos
interface UserStats {
  messages_sent_total: number;
  reactions_received_total: number;
  hearts_total: number;
  laughs_total: number;
  ideas_total: number;
  poops_total: number;
  streak_current_days: number;
  streak_longest_days: number;
  last_message_at: string | null;
}

// Estad√≠sticas diarias para c√°lculos de banners que requieren datos temporales
interface DailyStats {
  day: string;        // Fecha en formato YYYY-MM-DD
  messages: number;   // Mensajes enviados ese d√≠a
  hearts: number;     // ‚ù§Ô∏è recibidos ese d√≠a
  laughs: number;     // üòÇ recibidos ese d√≠a
  ideas: number;      // üí° recibidos ese d√≠a
  poops: number;      // üí© recibidos ese d√≠a
}

// Informaci√≥n del progreso hacia un banner espec√≠fico
interface BannerProgress {
  current: number;      // Progreso actual (ej: 75)
  max: number;          // Progreso necesario para desbloquear (ej: 100)  
  unlocked: boolean;    // ¬øYa tiene este banner el usuario?
  description: string;  // Texto explicativo del progreso (ej: "75/100 reacciones recibidas")
}

export const useBannerStats = () => {
  const { user } = useAuth();           // Usuario actual autenticado
  const { toast } = useToast();         // Para mostrar notificaciones
  
  // Estados principales del hook
  const [stats, setStats] = useState<UserStats | null>(null);        // Estad√≠sticas generales
  const [dailyStats, setDailyStats] = useState<DailyStats[]>([]);    // Estad√≠sticas diarias
  const [userBanners, setUserBanners] = useState<any[]>([]);         // Banners desbloqueados
  const [loading, setLoading] = useState(true);                      // Estado de carga

  /**
   * üîÑ Efecto principal: Cargar datos cuando el usuario cambia
   * Se ejecuta cuando el usuario se loguea/desloguea
   */
  useEffect(() => {
    if (!user) return;    // Si no hay usuario autenticado, no hacer nada

    const loadStats = async () => {
      try {
        // üìä Cargar estad√≠sticas generales del usuario
        const { data: statsData } = await (supabase as any)
          .from('user_stats')
          .select('*')
          .eq('user_id', user.id)
          .single();

        // üìÖ Cargar estad√≠sticas diarias de los √∫ltimos 30 d√≠as
        // Necesarias para banners que requieren datos temporales
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        
        const { data: dailyData } = await (supabase as any)
          .from('user_daily_stats')
          .select('*')
          .eq('user_id', user.id)
          .gte('day', thirtyDaysAgo.toISOString().split('T')[0])
          .order('day', { ascending: false });

        // üèÜ Cargar banners desbloqueados por el usuario
        // Incluye informaci√≥n completa del banner desde la tabla 'banners'
        const { data: bannersData } = await (supabase as any)
          .from('user_banners')
          .select('*, banners(*)')    // JOIN con tabla de banners
          .eq('user_id', user.id);

        // üìù Establecer estad√≠sticas (con valores por defecto si no existen)
        setStats(statsData || {
          messages_sent_total: 0,
          reactions_received_total: 0,
          hearts_total: 0,
          laughs_total: 0,
          ideas_total: 0,
          poops_total: 0,
          streak_current_days: 0,
          streak_longest_days: 0,
          last_message_at: null
        });
        
        // üìä Establecer estad√≠sticas diarias y banners
        setDailyStats(dailyData || []);
        setUserBanners(bannersData || []);
        
      } catch (error: any) {
        console.error('Error loading banner stats:', error);
        // üö® Mostrar error al usuario si algo falla
        toast({
          title: "Error al cargar estad√≠sticas",
          description: error.message,
          variant: "destructive",
        });
      } finally {
        setLoading(false);    // ‚úÖ Terminar estado de carga
      }
    };

    loadStats();    // üöÄ Ejecutar la carga de datos
  }, [user, toast]);    // Dependencias: se ejecuta cuando user o toast cambian

  /**
   * üìä Funci√≥n para calcular el progreso hacia un banner espec√≠fico
   * 
   * @param bannerId - ID √∫nico del banner (ej: 'leyenda', 'goat', etc.)
   * @returns BannerProgress con progreso actual, m√°ximo, estado y descripci√≥n
   * 
   * üéØ ¬øC√≥mo funciona?
   * 1. Verifica si el usuario ya tiene el banner desbloqueado
   * 2. Seg√∫n el ID del banner, calcula su progreso espec√≠fico
   * 3. Devuelve informaci√≥n completa para mostrar en la interfaz
   */
  const getBannerProgress = (bannerId: string): BannerProgress => {
    // üîÑ Si no hay estad√≠sticas cargadas, mostrar estado de carga
    if (!stats) {
      return { current: 0, max: 1, unlocked: false, description: 'Cargando...' };
    }

    // ‚úÖ Verificar si el usuario ya tiene este banner desbloqueado
    const isUnlocked = userBanners.some(ub => ub.banner_id === bannerId);
    
    // üéØ Calcular progreso seg√∫n el tipo de banner
    switch (bannerId) {
      case 'nuevo-h':    // üÜï Banner para primer mensaje
        return {
          current: Math.min(stats.messages_sent_total, 1),  // M√°ximo 1 para el c√°lculo
          max: 1,                                            // Solo necesita 1 mensaje
          unlocked: isUnlocked,
          description: `${stats.messages_sent_total}/1 mensajes enviados`
        };
        
      case 'leyenda':    // üèÜ Banner para usuarios populares
        return {
          current: stats.reactions_received_total,  // Total de reacciones recibidas
          max: 100,                                 // Necesita 100 reacciones
          unlocked: isUnlocked,
          description: `${stats.reactions_received_total}/100 reacciones recibidas`
        };
        
      case 'goat':       // üêê Banner para quien recibe muchos corazones
        return {
          current: stats.hearts_total,    // Total de ‚ù§Ô∏è recibidos
          max: 50,                        // Necesita 50 corazones
          unlocked: isUnlocked,
          description: `${stats.hearts_total}/50 ‚ù§Ô∏è recibidos`
        };
        
      case 'payaso':
        return {
          current: stats.laughs_total,
          max: 20,
          unlocked: isUnlocked,
          description: `${stats.laughs_total}/20 üòÇ recibidos`
        };
        
      case 'brujo':
        return {
          current: stats.ideas_total,
          max: 15,
          unlocked: isUnlocked,
          description: `${stats.ideas_total}/15 üí° recibidos`
        };
        
      case 'todo-terreno':    // üåü Banner para equilibrio en reacciones
        // Calcula el m√≠nimo entre todos los tipos de reacciones
        const minReactions = Math.min(stats.hearts_total, stats.ideas_total, stats.laughs_total);
        return {
          current: minReactions,    // El progreso es el m√≠nimo de todas
          max: 5,                   // Necesita 5 de cada tipo m√≠nimo
          unlocked: isUnlocked,
          description: `${stats.hearts_total} ‚ù§Ô∏è, ${stats.ideas_total} üí°, ${stats.laughs_total} üòÇ (m√≠n: ${minReactions})`
        };
        
      case 'modo-diablo':
        return {
          current: stats.messages_sent_total,
          max: 200,
          unlocked: isUnlocked,
          description: `${stats.messages_sent_total}/200 mensajes enviados`
        };
        
      case 'constante':
        return {
          current: stats.streak_current_days,
          max: 7,
          unlocked: isUnlocked,
          description: `${stats.streak_current_days}/7 d√≠as consecutivos`
        };
        
      case 'inmortal':
        return {
          current: stats.streak_current_days,
          max: 30,
          unlocked: isUnlocked,
          description: `${stats.streak_current_days}/30 d√≠as consecutivos`
        };
        
      case 'corazon-oro':    // üíõ Banner para r√©cord diario de corazones
        // Buscar corazones recibidos hoy
        const todayHearts = dailyStats.find(d => d.day === new Date().toISOString().split('T')[0])?.hearts || 0;
        // Encontrar el m√°ximo hist√≥rico (incluyendo hoy)
        const maxDailyHearts = Math.max(...dailyStats.map(d => d.hearts), todayHearts);
        return {
          current: maxDailyHearts,    // El r√©cord personal
          max: 20,                    // Necesita 20 ‚ù§Ô∏è en un solo d√≠a
          unlocked: isUnlocked,
          description: `${maxDailyHearts}/20 ‚ù§Ô∏è en un d√≠a (m√°ximo alcanzado)`
        };
        
      case 'bello-cur':      // üíñ Banner para popularidad semanal
        // Calcular corazones en los √∫ltimos 7 d√≠as
        const last7Days = dailyStats.slice(0, 7);    // Los primeros 7 (m√°s recientes)
        const heartsLast7 = last7Days.reduce((sum, day) => sum + day.hearts, 0);
        return {
          current: heartsLast7,     // Corazones en √∫ltima semana
          max: 25,                  // Necesita 25 ‚ù§Ô∏è en 7 d√≠as
          unlocked: isUnlocked,
          description: `${heartsLast7}/25 ‚ù§Ô∏è en los √∫ltimos 7 d√≠as`
        };
        
      case 'misterioso':     // üïµÔ∏è Banner especial con l√≥gica compleja
        return {
          current: isUnlocked ? 1 : 0,    // Solo 0 o 1
          max: 1,                         // Banner binario
          unlocked: isUnlocked,
          description: isUnlocked ? 'Desbloqueado' : 'Requiere 7 d√≠as sin mensajes + 1 mensaje'
        };
        
      default:              // üîÆ Banners desconocidos o especiales
        return {
          current: 0,
          max: 1,
          unlocked: isUnlocked,
          description: 'Banner especial'
        };
    }
  };

  /**
   * üîê Funci√≥n para canjear c√≥digos secretos
   * 
   * @param code - C√≥digo secreto ingresado por el usuario
   * @returns Promise<boolean> - true si se canje√≥ exitosamente
   * 
   * üéØ ¬øC√≥mo funciona?
   * 1. Valida que haya usuario logueado y c√≥digo no vac√≠o
   * 2. Llama a la funci√≥n RPC de Supabase 'award_banner_with_code'
   * 3. La funci√≥n RPC verifica el c√≥digo y otorga el banner si es v√°lido
   * 4. Recarga la lista de banners del usuario
   * 5. Muestra notificaci√≥n de √©xito o error
   */
  const redeemSecretCode = async (code: string): Promise<boolean> => {
    // üîí Validaciones b√°sicas
    if (!user || !code.trim()) return false;

    try {
      // üöÄ Llamar a funci√≥n RPC personalizada en Supabase
      const { data, error } = await (supabase as any)
        .rpc('award_banner_with_code', {
          p_code: code.trim()      // Solo el c√≥digo, la funci√≥n obtiene el user_id internamente
        });

      // ‚ùå Si hay error, el c√≥digo es incorrecto
      if (error) {
        toast({
          title: "C√≥digo incorrecto",
          description: "El c√≥digo que ingresaste no es v√°lido",
          variant: "destructive",
        });
        return false;
      }

      // ‚úÖ Si hay data, el c√≥digo fue v√°lido
      if (data) {
        toast({
          title: "¬°Banner desbloqueado!",
          description: "Has obtenido el banner 'Fundador y Rey del Todo' üëëüî•",
        });
        
        // üîÑ Recargar banners del usuario para actualizar la interfaz
        const { data: bannersData } = await (supabase as any)
          .from('user_banners')
          .select('*, banners(*)')
          .eq('user_id', user.id);
        
        setUserBanners(bannersData || []);
        return true;
      }

      return false;
    } catch (error: any) {
      console.error('Error redeeming code:', error);
      // üö® Error de conexi√≥n o similar
      toast({
        title: "Error",
        description: "No se pudo canjear el c√≥digo",
        variant: "destructive",
      });
      return false;
    }
  };

  // üì§ Exportar todos los datos y funciones que otros componentes necesitan
  return {
    stats,              // Estad√≠sticas generales del usuario
    dailyStats,         // Estad√≠sticas diarias
    userBanners,        // Banners permanentes desbloqueados
    loading,            // Estado de carga
    getBannerProgress,  // Funci√≥n para calcular progreso de banners
    redeemSecretCode,   // Funci√≥n para canjear c√≥digos secretos
  };
};