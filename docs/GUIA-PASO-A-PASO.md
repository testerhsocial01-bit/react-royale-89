# üöÄ Gu√≠a Paso a Paso: Sistema de Banners

## üìö √çndice
1. [Flujo Completo: Usuario Env√≠a Mensaje](#flujo-completo-usuario-env√≠a-mensaje)
2. [Flujo Completo: Usuario Recibe Reacci√≥n](#flujo-completo-usuario-recibe-reacci√≥n)
3. [Flujo Completo: Canjear C√≥digo Secreto](#flujo-completo-canjear-c√≥digo-secreto)
4. [C√≥mo se Calculan los Banners Autom√°ticos](#c√≥mo-se-calculan-los-banners-autom√°ticos)
5. [C√≥mo Agregar un Nuevo Banner](#c√≥mo-agregar-un-nuevo-banner)
6. [C√≥mo Debuggear Problemas](#c√≥mo-debuggear-problemas)

---

## üîÑ Flujo Completo: Usuario Env√≠a Mensaje

### Paso 1: Usuario escribe y env√≠a mensaje
```
üë§ Usuario escribe: "¬°Hola a todos!"
üíª Hace clic en "Enviar"
```

### Paso 2: Frontend procesa el mensaje
```javascript
// En ChatAppV2.tsx
const handleSendMessage = async (content) => {
  await sendMessage(content);  // useChat hook
};
```

### Paso 3: Hook useChat guarda en base de datos
```javascript
// En useChat.tsx
const sendMessage = async (content) => {
  const { data, error } = await supabase
    .from('messages')
    .insert({
      content: content,
      user_id: user.id,
      room_id: currentRoom.id
    });
};
```

### Paso 4: Base de datos guarda el mensaje
```sql
-- Tabla: messages
INSERT INTO messages (id, content, user_id, room_id, created_at)
VALUES ('uuid-123', '¬°Hola a todos!', 'user-456', 'room-789', NOW());
```

### Paso 5: Trigger autom√°tico se ejecuta
```sql
-- Funci√≥n: update_user_stats_on_message()
-- Se ejecuta autom√°ticamente despu√©s del INSERT

UPDATE user_stats SET
  messages_sent_total = messages_sent_total + 1,
  last_message_at = NOW()
WHERE user_id = NEW.user_id;
```

### Paso 6: Verificaci√≥n de banners por trigger
```sql
-- Funci√≥n: award_banner_on_milestone()
-- Se ejecuta despu√©s de actualizar estad√≠sticas

-- Ejemplo: Si lleg√≥ a 200 mensajes, otorgar "modo-diablo"
IF (SELECT messages_sent_total FROM user_stats WHERE user_id = NEW.user_id) >= 200 THEN
  INSERT INTO user_banners (user_id, banner_id, unlocked_at)
  VALUES (NEW.user_id, 'modo-diablo', NOW())
  ON CONFLICT DO NOTHING;
END IF;
```

### Paso 7: Supabase notifica cambios en tiempo real
```javascript
// useChat hook est√° suscrito a cambios
supabase
  .from('messages')
  .on('INSERT', (payload) => {
    setMessages(prev => [...prev, payload.new]);  // Nuevo mensaje aparece
  })
  .subscribe();
```

### Paso 8: Hooks reaccionan a los cambios
```javascript
// useBannerStats detecta cambio en user_stats
useEffect(() => {
  // Recargar estad√≠sticas cuando user cambia
  loadStats();
}, [user]);

// useAutomaticBanners recalcula con nuevos mensajes
const automaticBanners = useMemo(() => {
  // Analizar todos los mensajes y calcular banners autom√°ticos
}, [messages, currentUserId]);
```

### Paso 9: Interfaz se actualiza autom√°ticamente
```javascript
// ChatAppV2.tsx renderiza con nuevos datos
{messages.map((message) => {
  const userBanners = getUserBanners(message.user_id);  // Incluye nuevos banners
  return (
    <MessageBubbleV2
      message={message}
      automaticBanners={userBanners}
    />
  );
})}
```

### üéØ Resultado final:
- ‚úÖ Mensaje aparece en el chat
- ‚úÖ Contador de mensajes del usuario aumenta
- ‚úÖ Si alcanz√≥ un hito, nuevo banner se desbloquea
- ‚úÖ Banners autom√°ticos se recalculan
- ‚úÖ Todo se actualiza en tiempo real para todos los usuarios

---

## ‚ù§Ô∏è Flujo Completo: Usuario Recibe Reacci√≥n

### Paso 1: Usuario hace clic en reacci√≥n
```
üë§ Usuario ve mensaje de otro usuario
üòç Hace clic en bot√≥n "‚ù§Ô∏è"
```

### Paso 2: Frontend procesa la reacci√≥n
```javascript
// En MessageBubbleV2.tsx
const handleReaction = (emoji) => {
  onToggleReaction?.(emoji);  // Callback al padre
};

// En ChatAppV2.tsx  
const handleReaction = async (messageId, emoji) => {
  await addReaction(messageId, emoji);  // useChat hook
};
```

### Paso 3: Hook useChat guarda la reacci√≥n
```javascript
// En useChat.tsx
const addReaction = async (messageId, emoji) => {
  const { data, error } = await supabase
    .from('message_reactions')
    .insert({
      message_id: messageId,
      user_id: user.id,
      emoji: emoji
    });
};
```

### Paso 4: Base de datos guarda la reacci√≥n
```sql
-- Tabla: message_reactions
INSERT INTO message_reactions (id, message_id, user_id, emoji, created_at)
VALUES ('uuid-abc', 'msg-123', 'reactor-456', '‚ù§Ô∏è', NOW());
```

### Paso 5: Trigger autom√°tico actualiza estad√≠sticas del AUTOR del mensaje
```sql
-- Funci√≥n: update_user_stats_on_reaction()
-- Se ejecuta autom√°ticamente despu√©s del INSERT en message_reactions

-- Primero encuentra qui√©n escribi√≥ el mensaje original
DECLARE author_id UUID;
SELECT user_id INTO author_id 
FROM messages 
WHERE id = NEW.message_id;

-- Luego actualiza las estad√≠sticas del AUTOR (no del que reacciona)
UPDATE user_stats SET
  reactions_received_total = reactions_received_total + 1,
  hearts_total = hearts_total + CASE WHEN NEW.emoji = '‚ù§Ô∏è' THEN 1 ELSE 0 END,
  laughs_total = laughs_total + CASE WHEN NEW.emoji = 'üòÇ' THEN 1 ELSE 0 END,
  ideas_total = ideas_total + CASE WHEN NEW.emoji = 'üí°' THEN 1 ELSE 0 END,
  poops_total = poops_total + CASE WHEN NEW.emoji = 'üí©' THEN 1 ELSE 0 END
WHERE user_id = author_id;
```

### Paso 6: Verificaci√≥n de banners por hitos
```sql
-- Funci√≥n: award_banner_on_milestone()
-- Verifica si el AUTOR del mensaje merece un nuevo banner

DECLARE stats_row user_stats%ROWTYPE;
SELECT * INTO stats_row FROM user_stats WHERE user_id = author_id;

-- Ejemplo: Si lleg√≥ a 50 corazones, otorgar "goat"
IF stats_row.hearts_total >= 50 THEN
  INSERT INTO user_banners (user_id, banner_id, unlocked_at)
  VALUES (author_id, 'goat', NOW())
  ON CONFLICT DO NOTHING;
END IF;

-- Ejemplo: Si lleg√≥ a 100 reacciones totales, otorgar "leyenda"
IF stats_row.reactions_received_total >= 100 THEN
  INSERT INTO user_banners (user_id, banner_id, unlocked_at)
  VALUES (author_id, 'leyenda', NOW())
  ON CONFLICT DO NOTHING;
END IF;
```

### Paso 7: Supabase notifica cambios
```javascript
// useChat suscrito a cambios en message_reactions
supabase
  .from('message_reactions')
  .on('INSERT', (payload) => {
    // Actualizar lista de reacciones
    updateMessageReactions(payload.new);
  })
  .subscribe();
```

### Paso 8: Hooks reaccionan a los cambios
```javascript
// useBannerStats del AUTOR detecta cambio en sus estad√≠sticas
// (si est√° conectado al mismo tiempo)
useEffect(() => {
  const subscription = supabase
    .from('user_stats')
    .on('UPDATE', (payload) => {
      if (payload.new.user_id === user.id) {
        setStats(payload.new);  // Actualizar estad√≠sticas en tiempo real
      }
    })
    .subscribe();
}, [user]);

// useAutomaticBanners recalcula para todos los usuarios
const automaticBanners = useMemo(() => {
  // Con las nuevas reacciones, recalcular qui√©n tiene m√°s ‚ù§Ô∏è, etc.
  return calculateAutomaticBanners(messages, currentUserId);
}, [messages, currentUserId]);
```

### Paso 9: Interfaz se actualiza
```javascript
// El mensaje ahora muestra la nueva reacci√≥n
<div className="flex items-center gap-2">
  {reactionCounts.hearts > 0 && (
    <span className="text-sm">‚ù§Ô∏è {reactionCounts.hearts}</span>
  )}
  {/* ...otras reacciones */}
</div>

// El autor puede ver nuevos banners autom√°ticos
{automaticBanners.map(banner => (
  <UserBanner key={banner.id} banner={banner} />
))}
```

### üéØ Resultado final:
- ‚úÖ Reacci√≥n aparece en el mensaje
- ‚úÖ Estad√≠sticas del AUTOR del mensaje se actualizan
- ‚úÖ Si el autor alcanz√≥ un hito, recibe nuevo banner permanente
- ‚úÖ Banners autom√°ticos se recalculan (ej: "Coraz√≥n de Oro")
- ‚úÖ Todos ven los cambios en tiempo real

---

## üîê Flujo Completo: Canjear C√≥digo Secreto

### Paso 1: Usuario va a p√°gina de banners
```
üë§ Usuario navega a /banners
üîç Ve secci√≥n "C√≥digo Secreto"
‚å®Ô∏è Escribe: "REY_DEL_TODO_2025"
üñ±Ô∏è Hace clic en "Canjear"
```

### Paso 2: Frontend valida y procesa
```javascript
// En Banners.tsx
const handleRedeemCode = async () => {
  if (!secretCode.trim()) return;           // Validar que hay c√≥digo
  
  setIsRedeemingCode(true);                 // Mostrar loading
  const success = await redeemSecretCode(secretCode);
  if (success) {
    setSecretCode('');                      // Limpiar input
  }
  setIsRedeemingCode(false);               // Ocultar loading
};
```

### Paso 3: Hook llama funci√≥n RPC de Supabase
```javascript
// En useBannerStats.tsx
const redeemSecretCode = async (code) => {
  try {
    const { data, error } = await supabase
      .rpc('award_banner_with_code', {      // Funci√≥n personalizada de BD
        p_user_id: user.id,
        p_code: code.trim()
      });
    
    if (error) {
      // Mostrar error "c√≥digo incorrecto"
      return false;
    }
    
    if (data) {
      // Mostrar √©xito "banner desbloqueado"
      return true;
    }
  } catch (error) {
    // Manejar errores de conexi√≥n
    return false;
  }
};
```

### Paso 4: Base de datos ejecuta funci√≥n RPC
```sql
-- Funci√≥n: award_banner_with_code(p_user_id UUID, p_code TEXT)

CREATE OR REPLACE FUNCTION award_banner_with_code(p_user_id UUID, p_code TEXT)
RETURNS BOOLEAN AS $$
DECLARE
  banner_to_award TEXT;
BEGIN
  -- Verificar qu√© banner corresponde al c√≥digo
  CASE p_code
    WHEN 'REY_DEL_TODO_2025' THEN
      banner_to_award := 'fundador';
    WHEN 'OTRO_CODIGO_SECRETO' THEN  
      banner_to_award := 'otro-banner';
    ELSE
      RETURN FALSE;  -- C√≥digo inv√°lido
  END CASE;
  
  -- Verificar que no lo tenga ya
  IF EXISTS (SELECT 1 FROM user_banners WHERE user_id = p_user_id AND banner_id = banner_to_award) THEN
    RETURN FALSE;  -- Ya lo tiene
  END IF;
  
  -- Otorgar el banner
  INSERT INTO user_banners (user_id, banner_id, unlocked_at)
  VALUES (p_user_id, banner_to_award, NOW());
  
  RETURN TRUE;  -- √âxito
END;
$$ LANGUAGE plpgsql;
```

### Paso 5: Frontend recibe respuesta
```javascript
// En useBannerStats.tsx (continuaci√≥n)
if (data) {  // data = TRUE si fue exitoso
  toast({
    title: "¬°Banner desbloqueado!",
    description: "Has obtenido el banner 'Fundador y Rey del Todo' üëëüî•",
  });
  
  // Recargar banners del usuario
  const { data: bannersData } = await supabase
    .from('user_banners')
    .select('*, banners(*)')
    .eq('user_id', user.id);
  
  setUserBanners(bannersData || []);
  return true;
}
```

### Paso 6: Interfaz se actualiza autom√°ticamente
```javascript
// En Banners.tsx, el hook reacciona al cambio en userBanners
const unlockedCount = userBanners.length;  // Ahora incluye el nuevo banner

// Las tarjetas de banners se actualizan
{DETAILED_BANNERS.map((banner) => {
  const progress = getBannerProgress(banner.id);  // Ahora unlocked = true
  return (
    <BannerCard
      banner={banner}
      isUnlocked={progress.unlocked}  // ‚úÖ Ahora es true
      progress={progress.current}
      maxProgress={progress.max}
    />
  );
})}
```

### Paso 7: Banner aparece en el chat
```javascript
// En ChatAppV2.tsx, el usuario puede equipar el nuevo banner
// Si est√° en su lista de banners equipados, aparece en sus mensajes
<MessageBubbleV2
  message={message}
  automaticBanners={automaticBanners}
  // Los banners permanentes incluyen el nuevo "fundador"
/>
```

### üéØ Resultado final:
- ‚úÖ C√≥digo se valida correctamente
- ‚úÖ Banner "Fundador y Rey del Todo" se agrega a la colecci√≥n
- ‚úÖ Usuario recibe notificaci√≥n de √©xito
- ‚úÖ Banner aparece como "Desbloqueado" en la p√°gina
- ‚úÖ Usuario puede equiparlo en su perfil
- ‚úÖ Banner aparece con efectos especiales en el chat

---

## ‚ö° C√≥mo se Calculan los Banners Autom√°ticos

### Concepto: ¬øQu√© son los banners autom√°ticos?
Los banners autom√°ticos aparecen **din√°micamente** bas√°ndose en el estado actual del chat. No se guardan en la base de datos, se calculan en tiempo real.

### Ejemplo: Banner "N√∫mero 1"

#### Paso 1: Analizar todos los mensajes del chat actual
```javascript
// En useAutomaticBanners.tsx
const userStats = useMemo(() => {
  const stats = {};
  
  // Por cada mensaje en el chat
  messages.forEach(message => {
    const userId = message.user_id;
    
    // Inicializar stats del usuario si no existe
    if (!stats[userId]) {
      stats[userId] = {
        totalReactions: 0,
        hearts: 0,
        laughs: 0,
        ideas: 0,
        messages: 0
      };
    }
    
    // Contar este mensaje
    stats[userId].messages += 1;
    
    // Contar reacciones de este mensaje
    message.reactions?.forEach(reaction => {
      stats[userId].totalReactions += 1;
      
      switch (reaction.emoji) {
        case '‚ù§Ô∏è':
          stats[userId].hearts += 1;
          break;
        case 'üòÇ':
          stats[userId].laughs += 1;
          break;
        case 'üí°':
          stats[userId].ideas += 1;
          break;
      }
    });
  });
  
  return stats;
}, [messages]);
```

#### Paso 2: Determinar qui√©n tiene m√°s reacciones
```javascript
// Encontrar al usuario con m√°s reacciones totales
const topUser = Object.entries(userStats).reduce((champion, [userId, stats]) => {
  if (stats.totalReactions > champion.totalReactions) {
    return { userId, totalReactions: stats.totalReactions };
  }
  return champion;
}, { userId: null, totalReactions: 0 });
```

#### Paso 3: Activar banner si aplica al usuario actual
```javascript
const automaticBanners = [];

// Solo si el usuario actual es el campe√≥n
if (topUser.userId === currentUserId && topUser.totalReactions > 0) {
  automaticBanners.push({
    id: 'numero-1',
    name: 'N√∫mero 1',
    emoji: 'üèÜ',
    rarity: 'epic',
    description: `Eres quien m√°s reacciones ha recibido (${topUser.totalReactions})`,
    isActive: true
  });
}
```

### Ejemplo: Banner "Coraz√≥n de Oro" (solo √∫ltimos 50 mensajes)

```javascript
// Analizar solo mensajes recientes para banners temporales
const recentMessages = messages.slice(-50);  // √öltimos 50 mensajes

const recentHeartStats = {};
recentMessages.forEach(message => {
  const userId = message.user_id;
  const heartCount = message.reactions?.filter(r => r.emoji === '‚ù§Ô∏è').length || 0;
  
  recentHeartStats[userId] = (recentHeartStats[userId] || 0) + heartCount;
});

// Encontrar quien tiene m√°s ‚ù§Ô∏è en mensajes recientes
const heartChampion = Object.entries(recentHeartStats).reduce((champ, [userId, hearts]) => {
  return hearts > champ.hearts ? { userId, hearts } : champ;
}, { userId: null, hearts: 0 });

if (heartChampion.userId === currentUserId && heartChampion.hearts >= 5) {
  automaticBanners.push({
    id: 'corazon-oro-auto',
    name: 'Coraz√≥n de Oro',
    emoji: 'üíõ',
    rarity: 'rare',
    description: `Eres quien m√°s ‚ù§Ô∏è ha recibido recientemente (${heartChampion.hearts})`,
    isActive: true
  });
}
```

### üîÑ Cu√°ndo se recalculan:

1. **Nuevo mensaje enviado** ‚Üí `messages` cambia ‚Üí `useMemo` recalcula
2. **Nueva reacci√≥n agregada** ‚Üí `messages` se actualiza ‚Üí rec√°lculo autom√°tico
3. **Usuario diferente** ‚Üí `currentUserId` cambia ‚Üí rec√°lculo para nuevo usuario

### üéØ Ventajas de banners autom√°ticos:
- ‚úÖ **Tiempo real:** Aparecen y desaparecen instant√°neamente
- ‚úÖ **Din√°micos:** Se adaptan al estado actual del chat
- ‚úÖ **Competitivos:** Crean competencia entre usuarios
- ‚úÖ **Sin almacenamiento:** No ocupan espacio en base de datos

---

## ‚ûï C√≥mo Agregar un Nuevo Banner

### Escenario: Queremos crear banner "Madrugador" para quien env√≠a mensaje antes de las 6 AM

#### Paso 1: Decidir el tipo de banner

**Opci√≥n A: Banner Autom√°tico** (temporal, basado en chat actual)
```javascript
// Se activa si tienes mensajes de madrugada en el chat actual
// Desaparece si otros tambi√©n env√≠an mensajes de madrugada
```

**Opci√≥n B: Banner por Misi√≥n** (permanente, basado en estad√≠sticas)
```javascript
// Se desbloquea permanentemente al enviar 5 mensajes antes de las 6 AM
// Una vez desbloqueado, lo tienes para siempre
```

Vamos con **Opci√≥n B** para este ejemplo.

#### Paso 2: Agregar banner a la data
```javascript
// En bannerData.ts
export const DETAILED_BANNERS: DetailedBanner[] = [
  // ... banners existentes
  {
    id: 'madrugador',                    // ID √∫nico
    name: 'Madrugador',                  // Nombre mostrado
    emoji: 'üåÖ',                         // Emoji representativo
    rarity: 'rare',                      // Rareza (common, rare, epic, legendary)
    description: 'Los que trasnochan saben valorar la madrugada', // Descripci√≥n
    category: 'unlockable',              // Categor√≠a (automatic, unlockable, exclusive)
    requirement: 'Enviar 5 mensajes antes de las 6:00 AM',        // C√≥mo obtenerlo
    isTemporary: false,                  // No es temporal
    hasAnimation: false                  // Sin animaciones especiales
  }
];
```

#### Paso 3: Agregar campo a la base de datos (opcional)
```sql
-- Si queremos trackear mensajes de madrugada, agregar campo a user_stats
ALTER TABLE user_stats ADD COLUMN early_messages_total INTEGER DEFAULT 0;
```

#### Paso 4: Crear trigger para detectar mensajes de madrugada
```sql
-- Funci√≥n para actualizar estad√≠sticas cuando se env√≠a mensaje de madrugada
CREATE OR REPLACE FUNCTION update_early_message_stats()
RETURNS TRIGGER AS $$
BEGIN
  -- Verificar si es antes de las 6 AM (hora local)
  IF EXTRACT(HOUR FROM NEW.created_at AT TIME ZONE 'America/Mexico_City') < 6 THEN
    -- Incrementar contador de mensajes de madrugada
    UPDATE user_stats SET
      early_messages_total = early_messages_total + 1
    WHERE user_id = NEW.user_id;
    
    -- Verificar si merece el banner
    IF (SELECT early_messages_total FROM user_stats WHERE user_id = NEW.user_id) >= 5 THEN
      INSERT INTO user_banners (user_id, banner_id, unlocked_at)
      VALUES (NEW.user_id, 'madrugador', NOW())
      ON CONFLICT DO NOTHING;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Crear trigger
CREATE TRIGGER trigger_early_message_stats
  AFTER INSERT ON messages
  FOR EACH ROW
  EXECUTE FUNCTION update_early_message_stats();
```

#### Paso 5: Agregar l√≥gica de progreso al hook
```javascript
// En useBannerStats.tsx, dentro de getBannerProgress()
case 'madrugador':
  return {
    current: stats.early_messages_total || 0,        // Mensajes de madrugada actuales
    max: 5,                                          // Necesarios para desbloquear
    unlocked: isUnlocked,                            // ¬øYa lo tiene?
    description: `${stats.early_messages_total || 0}/5 mensajes antes de las 6 AM`
  };
```

#### Paso 6: Agregar l√≥gica de activaci√≥n autom√°tica (opcional)
```javascript
// En useAutomaticBanners.tsx, si queremos versi√≥n autom√°tica tambi√©n
const earlyMessagesToday = messages.filter(message => {
  const messageDate = new Date(message.created_at);
  const today = new Date();
  const isToday = messageDate.toDateString() === today.toDateString();
  const isEarly = messageDate.getHours() < 6;
  const isFromUser = message.user_id === currentUserId;
  
  return isToday && isEarly && isFromUser;
}).length;

if (earlyMessagesToday > 0) {
  automaticBanners.push({
    id: 'madrugador-auto',
    name: 'Madrugador Activo',
    emoji: 'üåÖ',
    rarity: 'rare',
    description: `Has enviado ${earlyMessagesToday} mensaje(s) de madrugada hoy`,
    isActive: true
  });
}
```

#### Paso 7: Verificar en la interfaz
```javascript
// En Banners.tsx, el nuevo banner aparecer√° autom√°ticamente porque:
// 1. Est√° en DETAILED_BANNERS
// 2. getBannerProgress() maneja su caso
// 3. El componente mapea todos los banners autom√°ticamente

{DETAILED_BANNERS.map((banner) => {
  const progress = getBannerProgress(banner.id);  // Incluye 'madrugador'
  return (
    <BannerCard
      key={banner.id}
      banner={banner}
      isUnlocked={progress.unlocked}
      progress={progress.current}      // 0-5
      maxProgress={progress.max}       // 5
      description={progress.description} // "X/5 mensajes antes de las 6 AM"
    />
  );
})}
```

### üß™ Pruebas

#### C√≥mo probar el nuevo banner:

1. **Simular hora de madrugada en base de datos:**
```sql
-- Insertar mensaje con timestamp de madrugada
INSERT INTO messages (id, content, user_id, room_id, created_at)
VALUES (gen_random_uuid(), 'Mensaje de prueba', 'tu-user-id', 'room-id', '2024-01-01 05:30:00');
```

2. **Verificar que se actualiz√≥ la estad√≠stica:**
```sql
SELECT early_messages_total FROM user_stats WHERE user_id = 'tu-user-id';
-- Deber√≠a mostrar 1
```

3. **Repetir hasta llegar a 5 mensajes**

4. **Verificar que se otorg√≥ el banner:**
```sql
SELECT * FROM user_banners WHERE user_id = 'tu-user-id' AND banner_id = 'madrugador';
-- Deber√≠a mostrar el registro del banner
```

5. **Verificar en la interfaz:**
- Ir a `/banners`
- Buscar "Madrugador" en la secci√≥n "Misiones"
- Deber√≠a mostrar "‚úÖ Desbloqueado"

---

## üêõ C√≥mo Debuggear Problemas

### Problema 1: "El banner no aparece aunque cumpl√≠ la condici√≥n"

#### ‚úÖ Verificar la base de datos:
```sql
-- 1. ¬øSe guard√≥ el mensaje?
SELECT * FROM messages WHERE user_id = 'tu-user-id' ORDER BY created_at DESC LIMIT 5;

-- 2. ¬øSe actualiz√≥ la estad√≠stica?
SELECT * FROM user_stats WHERE user_id = 'tu-user-id';

-- 3. ¬øSe ejecut√≥ el trigger?
SELECT * FROM user_banners WHERE user_id = 'tu-user-id' AND banner_id = 'banner-esperado';
```

#### ‚úÖ Verificar el frontend:
```javascript
// En useBannerStats.tsx, agregar logs
console.log('Stats cargadas:', stats);
console.log('Banners del usuario:', userBanners);
console.log('Progreso calculado:', getBannerProgress('banner-esperado'));

// En BannerCard.tsx
console.log('Renderizando banner:', banner.id, 'Desbloqueado:', isUnlocked);
```

#### ‚úÖ Verificar hooks:
```javascript
// En useChat.tsx
console.log('Enviando mensaje:', content);
console.log('Respuesta de supabase:', data, error);

// En useBannerStats.tsx
useEffect(() => {
  console.log('Usuario cambi√≥, recargando stats:', user?.id);
}, [user]);
```

### Problema 2: "Banner autom√°tico no se activa en tiempo real"

#### ‚úÖ Verificar datos de entrada:
```javascript
// En useAutomaticBanners.tsx
console.log('Mensajes recibidos:', messages.length);
console.log('Usuario actual:', currentUserId);
console.log('Ejemplo de mensaje:', messages[0]);
```

#### ‚úÖ Verificar c√°lculos:
```javascript
// Dentro del useMemo
console.log('Estad√≠sticas calculadas:', userStats);
console.log('Campe√≥n actual:', topUser);
console.log('¬øAplica al usuario actual?', topUser.userId === currentUserId);
```

#### ‚úÖ Verificar dependencias:
```javascript
// Verificar que useMemo se ejecuta cuando debe
const automaticBanners = useMemo(() => {
  console.log('üîÑ Recalculando banners autom√°ticos');
  // ... l√≥gica
}, [messages, currentUserId]);  // ¬øEst√°n correctas las dependencias?
```

### Problema 3: "Error al canjear c√≥digo secreto"

#### ‚úÖ Verificar el c√≥digo:
```javascript
// En useBannerStats.tsx
const redeemSecretCode = async (code) => {
  console.log('Canjeando c√≥digo:', code);
  console.log('Usuario actual:', user?.id);
  
  try {
    const { data, error } = await supabase.rpc('award_banner_with_code', {
      p_user_id: user.id,
      p_code: code.trim()
    });
    
    console.log('Respuesta RPC:', { data, error });
    
  } catch (error) {
    console.error('Error en RPC:', error);
  }
};
```

#### ‚úÖ Verificar funci√≥n RPC en base de datos:
```sql
-- Probar la funci√≥n directamente
SELECT award_banner_with_code('tu-user-id', 'REY_DEL_TODO_2025');
-- Deber√≠a devolver TRUE

-- Verificar que existe la funci√≥n
SELECT * FROM pg_proc WHERE proname = 'award_banner_with_code';
```

### Problema 4: "Los cambios no se ven en tiempo real"

#### ‚úÖ Verificar suscripciones de Supabase:
```javascript
// En useChat.tsx
useEffect(() => {
  console.log('üîå Configurando suscripci√≥n a mensajes');
  
  const subscription = supabase
    .from('messages')
    .on('INSERT', (payload) => {
      console.log('üì® Nuevo mensaje recibido:', payload.new);
      setMessages(prev => [...prev, payload.new]);
    })
    .subscribe();
    
  return () => {
    console.log('üîå Limpiando suscripci√≥n');
    subscription.unsubscribe();
  };
}, []);
```

#### ‚úÖ Verificar estados de React:
```javascript
// Verificar que los estados se actualizan
useEffect(() => {
  console.log('üìä Messages actualizado:', messages.length);
}, [messages]);

useEffect(() => {
  console.log('üèÜ UserBanners actualizado:', userBanners.length);
}, [userBanners]);
```

### üõ†Ô∏è Herramientas √∫tiles para debugging:

#### 1. **Console del navegador:**
- Abrir DevTools (F12)
- Ir a "Console"
- Ver los logs que agregaste en el c√≥digo

#### 2. **Network tab:**
- Ver las llamadas a Supabase
- Verificar que se env√≠an los datos correctos
- Revisar errores de conexi√≥n

#### 3. **Supabase Dashboard:**
- Ir a [app.supabase.com](https://app.supabase.com)
- Verificar datos en "Table Editor"
- Ejecutar queries en "SQL Editor"

#### 4. **React Developer Tools:**
- Extensi√≥n de Chrome/Firefox
- Ver estados de componentes
- Verificar props que se pasan

### üéØ Checklist de debugging:

#### Para banners que no aparecen:
- [ ] ¬øEst√° el banner en `bannerData.ts`?
- [ ] ¬øManeja `getBannerProgress()` este banner?
- [ ] ¬øSe ejecut√≥ el trigger de base de datos?
- [ ] ¬øSe actualiz√≥ `user_stats`?
- [ ] ¬øSe insert√≥ en `user_banners`?
- [ ] ¬øSe recargaron los datos en el frontend?

#### Para banners autom√°ticos:
- [ ] ¬øEst√°n llegando los mensajes correctos?
- [ ] ¬øEs correcto el `currentUserId`?
- [ ] ¬øSe ejecuta el `useMemo`?
- [ ] ¬øLa l√≥gica de c√°lculo es correcta?
- [ ] ¬øSe renderiza el componente con los banners?

#### Para c√≥digos secretos:
- [ ] ¬øExiste la funci√≥n RPC en base de datos?
- [ ] ¬øEl c√≥digo est√° en la funci√≥n RPC?
- [ ] ¬øSe llama correctamente desde frontend?
- [ ] ¬øEl usuario no tiene ya el banner?
- [ ] ¬øSe recargan los banners despu√©s del canje?

¬°Con esta gu√≠a paso a paso ya puedes entender, modificar y debuggear todo el sistema de banners! üöÄ